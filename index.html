<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>エコノミー・ヒーロー：見えざる手</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Kosugi+Maru&display=swap');
        body {
            font-family: 'Kosugi Maru', sans-serif;
            background-color: #1a202c;
            overflow: hidden;
            user-select: none;
        }
        canvas {
            display: block;
            touch-action: none;
        }
        .retro-text {
            text-shadow: 2px 2px 0px #000;
        }
        /* UI Overlay animations */
        @keyframes floatUp {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-20px); opacity: 0; }
        }
        .floating-text {
            position: absolute;
            pointer-events: none;
            animation: floatUp 1s ease-out forwards;
            font-weight: bold;
            font-size: 14px;
        }
    </style>
</head>
<body class="text-white h-screen w-screen flex flex-col">

    <!-- Header / HUD -->
    <div class="absolute top-0 left-0 w-full p-2 bg-gray-900/90 border-b border-gray-700 z-10 flex justify-between items-center text-sm md:text-base">
        <div class="flex gap-4">
            <div class="flex flex-col">
                <span class="text-yellow-400 font-bold">資金 (流動性)</span>
                <span id="goldDisplay" class="text-xl">¥1,000</span>
            </div>
            <div class="flex flex-col">
                <span class="text-green-400 font-bold">利率 (複利)</span>
                <span id="interestDisplay">5.0% / 5秒</span>
            </div>
            <div class="flex flex-col">
                <span class="text-blue-400 font-bold">GDP (スコア)</span>
                <span id="scoreDisplay">0</span>
            </div>
        </div>
        <div class="flex flex-col text-right">
            <span class="text-red-500 font-bold">インフレ波 (Wave)</span>
            <span id="waveDisplay" class="text-xl">1</span>
        </div>
        <div id="enemyInfo" class="text-xs text-gray-300 max-w-xs pl-4"></div>
    </div>

    <!-- Game Container -->
        <div class="relative flex-grow flex justify-center items-center bg-gray-800" id="gameContainer">
            <canvas id="gameCanvas"></canvas>

            <!-- Tower Management Panel -->
            <div id="towerPanel" class="absolute left-2 top-16 bg-gray-900/80 p-3 rounded-lg border border-gray-700 text-xs space-y-1 w-60 hidden z-10">
                <div class="text-sm font-bold text-yellow-300">タワー管理</div>
                <div id="towerName" class="text-lg text-white">タワー未選択</div>
                <div id="towerStats" class="text-gray-300">射程/ダメージ/クールダウン</div>
                <div class="flex gap-2 mt-1">
                    <button id="btnTowerUpgrade" class="flex-1 bg-indigo-700 hover:bg-indigo-600 text-white py-1 px-2 rounded border border-indigo-400 text-xs transition">
                        強化 <span id="towerUpgradeCost" class="text-yellow-300"></span>
                    </button>
                    <button id="btnTowerSell" class="flex-1 bg-gray-700 hover:bg-gray-600 text-white py-1 px-2 rounded border border-gray-400 text-xs transition">
                        売却/再配置 <span id="towerSellRefund" class="text-green-300"></span>
                    </button>
                </div>
                <div id="towerCosts" class="text-gray-400 text-[11px]"></div>
            </div>

            <!-- Action Bar (Bottom) -->
        <div class="absolute bottom-4 left-1/2 transform -translate-x-1/2 bg-gray-900/90 p-2 rounded-xl border border-gray-600 flex gap-2 z-10 shadow-lg">
            <button id="btnBuyBond" class="flex flex-col items-center justify-center w-20 h-20 bg-blue-900 hover:bg-blue-800 border border-blue-500 rounded transition relative group">
                <span class="text-xs font-bold text-blue-200">債券タワー</span>
                <span id="costBond" class="text-xs text-yellow-300">¥100</span>
                <div class="text-[10px] text-gray-400 mt-1">射程:中 連射:中</div>
                <!-- Tooltip -->
                <div class="absolute bottom-full mb-2 hidden group-hover:block w-48 bg-black text-xs p-2 rounded border border-gray-600">
                    安定資産。バランスが良い防衛タワー。
                </div>
            </button>

            <button id="btnBuyStock" class="flex flex-col items-center justify-center w-20 h-20 bg-red-900 hover:bg-red-800 border border-red-500 rounded transition relative group">
                <span class="text-xs font-bold text-red-200">株式タワー</span>
                <span id="costStock" class="text-xs text-yellow-300">¥250</span>
                <div class="text-[10px] text-gray-400 mt-1">射程:短 威力:高</div>
                <div class="absolute bottom-full mb-2 hidden group-hover:block w-48 bg-black text-xs p-2 rounded border border-gray-600">
                    ハイリスク・ハイリターン。高火力だが範囲が狭い。
                </div>
            </button>

            <button id="btnBuyRealEstate" class="flex flex-col items-center justify-center w-20 h-20 bg-green-900 hover:bg-green-800 border border-green-500 rounded transition relative group">
                <span class="text-xs font-bold text-green-200">不動産壁</span>
                <span id="costRealEstate" class="text-xs text-yellow-300">¥500</span>
                <div class="text-[10px] text-gray-400 mt-1">耐久:高 減速</div>
                <div class="absolute bottom-full mb-2 hidden group-hover:block w-48 bg-black text-xs p-2 rounded border border-gray-600">
                    敵の進行を物理的に阻む資産。
                </div>
            </button>

             <button id="btnHeroUpgrade" class="flex flex-col items-center justify-center w-20 h-20 bg-purple-900 hover:bg-purple-800 border border-purple-500 rounded transition relative group ml-4">
                <span class="text-xs font-bold text-purple-200">人材投資</span>
                <span id="costUpgrade" class="text-xs text-yellow-300">¥300</span>
                <div class="text-[10px] text-gray-400 mt-1">自己研鑽</div>
                <div class="absolute bottom-full mb-2 hidden group-hover:block w-48 bg-black text-xs p-2 rounded border border-gray-600">
                    ヒーローの攻撃力と移動速度を上げます（生産性向上）。
                </div>
            </button>
        </div>

        <!-- Start/Game Over Screen -->
        <div id="modalScreen" class="absolute inset-0 bg-black/80 flex flex-col items-center justify-center z-20">
            <h1 id="modalTitle" class="text-4xl md:text-6xl font-bold text-yellow-400 mb-4 retro-text">Economy Hero</h1>
            <p id="modalDesc" class="text-gray-300 mb-8 max-w-md text-center leading-relaxed p-4">
                あなたは経済を守るヒーローです。<br><br>
                1. 画面クリックで移動＆自動攻撃。<br>
                2. 敵が中央の「国庫」に到達するとゲームオーバー。<br>
                3. <span class="text-green-400 font-bold">お金を貯めると複利（利子）で増えます！</span><br>
                4. タワー（資産）を買いすぎると価格が上がります（需給の法則）。
            </p>
            <button id="btnStart" class="px-8 py-3 bg-yellow-500 hover:bg-yellow-400 text-black font-bold rounded text-xl transition transform hover:scale-105">
                市場介入開始 (Start)
            </button>
        </div>
    </div>

    <script>
        // --- Game Configuration & State ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('gameContainer');

        // State
        let gameState = 'START'; // START, PLAYING, GAMEOVER
        let lastTime = 0;
        let gold = 1000;
        let score = 0; // Represents GDP
        let wave = 1;
        let baseHealth = 100;
        let maxBaseHealth = 100;
        let interestRate = 0.05; // 5% per cycle
        let interestTimer = 0;
        const interestInterval = 5000; // 5 seconds
        let waveTimer = 0;
        let enemiesToSpawn = 0;
        let spawnInterval = 0;
        let spawnTimer = 0;
        let spawnQueue = [];

        // Entities
        let hero;
        let enemies = [];
        let towers = [];
        let projectiles = [];
        let particles = [];
        let floatingTexts = [];
        let selectedTower = null;

        // Economics (Supply & Demand Scaling)
        let costs = {
            bond: 100,
            stock: 250,
            realEstate: 500,
            upgrade: 300
        };
        const costMultipliers = {
            bond: 1.15,
            stock: 1.25,
            realEstate: 1.3,
            upgrade: 1.5
        };

        const towerUpgradeMultipliers = {
            range: 1.08,
            damage: 1.18,
            cooldown: 0.92
        };

        const sellRefundRate = 0.65;

        // UI Elements
        const elGold = document.getElementById('goldDisplay');
        const elInterest = document.getElementById('interestDisplay');
        const elScore = document.getElementById('scoreDisplay');
        const elWave = document.getElementById('waveDisplay');
        const elModal = document.getElementById('modalScreen');
        const elTitle = document.getElementById('modalTitle');
        const elDesc = document.getElementById('modalDesc');
        const elBtnStart = document.getElementById('btnStart');
        
        const btnBuyBond = document.getElementById('btnBuyBond');
        const btnBuyStock = document.getElementById('btnBuyStock');
        const btnBuyRealEstate = document.getElementById('btnBuyRealEstate');
        const btnHeroUpgrade = document.getElementById('btnHeroUpgrade');

        // Input
        let mouseX = 0;
        let mouseY = 0;
        let buildingMode = null; // 'bond', 'stock', 'realEstate' or null

        // --- Enemy Type Definitions ---
        const enemyTypes = {
            basic: {
                label: 'インフレゴースト',
                color: '#ef4444',
                barColor: '#10b981',
                hp: 30,
                speed: 40,
                rewardMult: 1,
                radius: 10,
                description: '標準的なインフレの化身。癖はないが数で押してくる。'
            },
            fast: {
                label: '高速投機家',
                color: '#f97316',
                barColor: '#facc15',
                hp: 22,
                speed: 80,
                rewardMult: 1.1,
                radius: 9,
                description: '低耐久だが素早く国庫に到達しようとするスプリンター。'
            },
            tank: {
                label: '重課税ゾンビ',
                color: '#60a5fa',
                barColor: '#3b82f6',
                hp: 80,
                speed: 25,
                rewardMult: 1.4,
                radius: 12,
                description: '鈍足だが頑丈。長期的に財政を圧迫する。'
            },
            healer: {
                label: '公共投資家',
                color: '#a855f7',
                barColor: '#c084fc',
                hp: 55,
                speed: 35,
                rewardMult: 1.2,
                radius: 11,
                healAmount: 12,
                healRadius: 90,
                healCooldown: 2.5,
                description: '周囲のインフレ圧力を回復させる。放置すると長期戦に。'
            },
            boss: {
                label: 'バブルボス',
                color: '#fde047',
                barColor: '#fbbf24',
                hp: 280,
                speed: 30,
                rewardMult: 6,
                radius: 16,
                description: '特定ウェーブで出現する巨悪。莫大な損失と報酬をもたらす。'
            }
        };

        const discoveredEnemyTypes = new Set(['basic']);

        // --- Classes ---

        class Hero {
            constructor() {
                this.x = canvas.width / 2;
                this.y = canvas.height / 2 + 50;
                this.targetX = this.x;
                this.targetY = this.y;
                this.speed = 180; // pixels per second
                this.radius = 12;
                this.color = '#a78bfa'; // Purple
                this.damage = 25;
                this.attackRange = 100;
                this.attackCooldown = 0.5; // seconds
                this.attackTimer = 0;
                this.level = 1;
            }

            update(dt) {
                // Movement
                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                const dist = Math.sqrt(dx*dx + dy*dy);

                if (dist > 5) {
                    this.x += (dx / dist) * this.speed * dt;
                    this.y += (dy / dist) * this.speed * dt;
                }

                // Auto Attack
                this.attackTimer -= dt;
                if (this.attackTimer <= 0) {
                    const target = getNearestEnemy(this.x, this.y, this.attackRange);
                    if (target) {
                        this.attack(target);
                        this.attackTimer = this.attackCooldown;
                    }
                }
            }

            attack(target) {
                // Visual Slash Effect
                createParticle(target.x, target.y, 'slash', this.color);
                target.takeDamage(this.damage);
            }

            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.lineWidth = 2;
                ctx.strokeStyle = '#fff';
                ctx.stroke();

                // Level Indicator
                ctx.fillStyle = '#fff';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`Lv.${this.level}`, this.x, this.y - 15);
            }

            upgrade() {
                this.level++;
                this.damage *= 1.2;
                this.speed *= 1.1;
                this.attackCooldown *= 0.9;
                createFloatingText(this.x, this.y, "生産性向上!", "#d8b4fe");
            }
        }

        class Enemy {
            constructor(wave, typeKey = 'basic') {
                this.typeKey = typeKey;
                this.type = enemyTypes[typeKey] || enemyTypes.basic;

                // Spawn at random edge
                if (Math.random() < 0.5) {
                    this.x = Math.random() < 0.5 ? -20 : canvas.width + 20;
                    this.y = Math.random() * canvas.height;
                } else {
                    this.x = Math.random() * canvas.width;
                    this.y = Math.random() < 0.5 ? -20 : canvas.height + 20;
                }

                this.targetX = canvas.width / 2;
                this.targetY = canvas.height / 2;

                // Stats scale with wave (Inflation)
                const inflationRate = 1 + (wave * 0.15);
                const waveSpeedBonus = wave * 2;
                this.hp = this.type.hp * inflationRate;
                this.maxHp = this.hp;
                this.speed = this.type.speed + waveSpeedBonus;
                const baseReward = 15 * (1 + wave * 0.05);
                this.reward = Math.floor(baseReward * this.type.rewardMult);
                this.radius = this.type.radius;
                this.color = this.type.color;
                this.barColor = this.type.barColor;
                this.frozen = 0; // Slow effect

                if (this.type.healAmount) {
                    this.healTimer = 0;
                }
            }

            update(dt) {
                if (this.frozen > 0) this.frozen -= dt;
                
                let currentSpeed = this.frozen > 0 ? this.speed * 0.5 : this.speed;

                if (this.type.healAmount) {
                    this.healTimer += dt;
                    if (this.healTimer >= this.type.healCooldown) {
                        this.healTimer = 0;
                        enemies.forEach(e => {
                            if (e === this || e.dead) return;
                            const dxh = e.x - this.x;
                            const dyh = e.y - this.y;
                            const dsth = Math.sqrt(dxh*dxh + dyh*dyh);
                            if (dsth <= this.type.healRadius && e.hp < e.maxHp) {
                                e.hp = Math.min(e.maxHp, e.hp + this.type.healAmount);
                                createFloatingText(e.x, e.y - 20, '+回復', '#a855f7');
                            }
                        });
                    }
                }

                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                const dist = Math.sqrt(dx*dx + dy*dy);

                if (dist < 20) {
                    // Hit base
                    takeBaseDamage(10);
                    this.dead = true;
                    createFloatingText(this.x, this.y, "-資産価値", "#ff0000");
                } else {
                    this.x += (dx / dist) * currentSpeed * dt;
                    this.y += (dy / dist) * currentSpeed * dt;
                }
            }

            takeDamage(amount) {
                this.hp -= amount;
                createFloatingText(this.x, this.y, Math.floor(amount), "#fff");
                if (this.hp <= 0) {
                    this.dead = true;
                    gold += this.reward;
                    score += this.reward;
                    createFloatingText(this.x, this.y, `+¥${this.reward}`, "#fbbf24");
                    createParticle(this.x, this.y, 'explosion', this.color);
                    updateUI();
                }
            }

            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.frozen > 0 ? '#3b82f6' : this.color;
                ctx.fill();

                // Health bar
                const hpPct = this.hp / this.maxHp;
                ctx.fillStyle = '#1f2937';
                ctx.fillRect(this.x - 10, this.y - 15, 20, 3);
                ctx.fillStyle = this.barColor || '#10b981';
                ctx.fillRect(this.x - 10, this.y - 15, 20 * hpPct, 3);

                // Type label
                ctx.fillStyle = '#ffffff';
                ctx.font = '9px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(this.type.label, this.x, this.y + this.radius + 10);
            }
        }

        class Tower {
            constructor(x, y, type, buildCost) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.range = 0;
                this.damage = 0;
                this.cooldown = 0;
                this.timer = 0;
                this.color = '#fff';
                this.level = 1;
                this.buildCost = buildCost;
                this.upgradeCost = Math.floor(buildCost * 0.8);
                this.invested = buildCost;

                if (type === 'bond') {
                    this.range = 150;
                    this.damage = 15;
                    this.cooldown = 1.0;
                    this.color = '#3b82f6'; // Blue
                    this.label = "債券";
                } else if (type === 'stock') {
                    this.range = 100;
                    this.damage = 45;
                    this.cooldown = 1.5;
                    this.color = '#ef4444'; // Red
                    this.label = "株式";
                } else if (type === 'realEstate') {
                    this.range = 60;
                    this.damage = 5;
                    this.cooldown = 0.2; // Slow aura
                    this.color = '#10b981'; // Green
                    this.label = "不動産";
                }
            }

            update(dt) {
                this.timer -= dt;
                if (this.timer <= 0) {
                    const target = getNearestEnemy(this.x, this.y, this.range);
                    if (target) {
                        if (this.type === 'realEstate') {
                            // Slow aura effect
                            target.frozen = 0.5;
                            target.takeDamage(this.damage);
                            this.timer = this.cooldown;
                            createParticle(target.x, target.y, 'slow', this.color);
                        } else {
                            // Shoot projectile
                            projectiles.push(new Projectile(this.x, this.y, target, this.damage, this.color));
                            this.timer = this.cooldown;
                        }
                    }
                }
            }

            draw(ctx) {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - 12, this.y - 12, 24, 24);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.strokeRect(this.x - 12, this.y - 12, 24, 24);

                if (selectedTower === this) {
                    ctx.strokeStyle = '#fbbf24';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(this.x - 15, this.y - 15, 30, 30);
                }
                
                // Range circle (faint)
                // ctx.beginPath();
                // ctx.arc(this.x, this.y, this.range, 0, Math.PI * 2);
                // ctx.strokeStyle = this.color;
                // ctx.globalAlpha = 0.1;
                // ctx.stroke();
                // ctx.globalAlpha = 1.0;

                ctx.fillStyle = '#fff';
                ctx.font = '9px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${this.label[0]}${this.level}`, this.x, this.y + 3);
            }

            attemptUpgrade() {
                if (gold < this.upgradeCost) {
                    createFloatingText(this.x, this.y - 24, '資金不足', '#ef4444');
                    return false;
                }

                gold -= this.upgradeCost;
                this.invested += this.upgradeCost;
                this.level += 1;
                this.range *= towerUpgradeMultipliers.range;
                this.damage *= towerUpgradeMultipliers.damage;
                this.cooldown *= towerUpgradeMultipliers.cooldown;
                this.upgradeCost = Math.floor(this.upgradeCost * costMultipliers[this.type]);

                createFloatingText(this.x, this.y - 24, `Lv.${this.level} 強化!`, '#fbbf24');
                createParticle(this.x, this.y, 'click', this.color);
                updateUI();
                updateTowerPanel();
                return true;
            }
        }

        class Projectile {
            constructor(x, y, target, damage, color) {
                this.x = x;
                this.y = y;
                this.target = target;
                this.damage = damage;
                this.color = color;
                this.speed = 300;
                this.dead = false;
            }

            update(dt) {
                if (this.target.dead) {
                    this.dead = true;
                    return;
                }

                const dx = this.target.x - this.x;
                const dy = this.target.y - this.y;
                const dist = Math.sqrt(dx*dx + dy*dy);

                if (dist < 10) {
                    this.target.takeDamage(this.damage);
                    this.dead = true;
                } else {
                    this.x += (dx / dist) * this.speed * dt;
                    this.y += (dy / dist) * this.speed * dt;
                }
            }

            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
            }
        }

        class Particle {
            constructor(x, y, type, color) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.color = color;
                this.life = 0.5; // seconds
                this.vx = (Math.random() - 0.5) * 100;
                this.vy = (Math.random() - 0.5) * 100;
            }

            update(dt) {
                this.life -= dt;
                this.x += this.vx * dt;
                this.y += this.vy * dt;
            }

            draw(ctx) {
                ctx.globalAlpha = this.life * 2;
                if (this.type === 'slash') {
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.x + this.vx/5, this.y + this.vy/5);
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                } else {
                    ctx.fillStyle = this.color;
                    ctx.fillRect(this.x, this.y, 3, 3);
                }
                ctx.globalAlpha = 1.0;
            }
        }

        // --- Core Functions ---

        function init() {
            resize();
            window.addEventListener('resize', resize);
            
            // Mouse Interactions
            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                if (gameState !== 'PLAYING') return;

                if (buildingMode) {
                    buildTower(x, y, buildingMode);
                    buildingMode = null;
                    document.body.style.cursor = 'default';
                } else {
                    const towerClicked = getTowerAt(x, y);
                    if (towerClicked) {
                        if (selectedTower === towerClicked) {
                            towerClicked.attemptUpgrade();
                        } else {
                            selectTower(towerClicked);
                        }
                    } else {
                        // Move Hero
                        selectTower(null);
                        hero.targetX = x;
                        hero.targetY = y;
                        createParticle(x, y, 'click', '#fff');
                    }
                }
            });

            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                mouseX = e.clientX - rect.left;
                mouseY = e.clientY - rect.top;
            });

            // Buttons
            btnStart.addEventListener('click', startGame);
            
            btnBuyBond.addEventListener('click', (e) => setBuildMode('bond', e));
            btnBuyStock.addEventListener('click', (e) => setBuildMode('stock', e));
            btnBuyRealEstate.addEventListener('click', (e) => setBuildMode('realEstate', e));
            btnHeroUpgrade.addEventListener('click', upgradeHero);
            document.getElementById('btnTowerUpgrade').addEventListener('click', upgradeSelectedTower);
            document.getElementById('btnTowerSell').addEventListener('click', sellSelectedTower);

            document.getElementById('enemyInfo').innerText = `${enemyTypes.basic.label}: ${enemyTypes.basic.description}`;
            document.getElementById('enemyInfo').title = `${enemyTypes.basic.label}: ${enemyTypes.basic.description}`;

            // Game Loop
            requestAnimationFrame(gameLoop);
        }

        function resize() {
            canvas.width = gameContainer.clientWidth;
            canvas.height = gameContainer.clientHeight;
        }

        function startGame() {
            gameState = 'PLAYING';
            elModal.classList.add('hidden');

            // Reset Vars
            gold = 1000;
            score = 0;
            wave = 1;
            baseHealth = 100;
            interestTimer = 0;
            spawnQueue = [];
            enemies = [];
            towers = [];
            projectiles = [];
            particles = [];
            discoveredEnemyTypes.clear();
            discoveredEnemyTypes.add('basic');
            document.getElementById('enemyInfo').innerText = `${enemyTypes.basic.label}: ${enemyTypes.basic.description}`;
            document.getElementById('enemyInfo').title = `${enemyTypes.basic.label}: ${enemyTypes.basic.description}`;
            
            // Reset Costs
            costs = { bond: 100, stock: 250, realEstate: 500, upgrade: 300 };
            selectedTower = null;
            updateTowerPanel();

            hero = new Hero();
            startWave();
            updateUI();
        }

        function setBuildMode(type, e) {
            e?.stopPropagation(); // prevent canvas click
            if (gold >= costs[type]) {
                buildingMode = type;
                document.body.style.cursor = 'crosshair';
                createFloatingText(canvas.width/2, canvas.height - 100, "建設場所を選択してください", "#fff");
            } else {
                createFloatingText(canvas.width/2, canvas.height - 100, "資金不足です (流動性枯渇)", "#ef4444");
            }
        }

        function buildTower(x, y, type) {
            const price = costs[type];
            if (gold >= price) {
                gold -= price;
                towers.push(new Tower(x, y, type, price));
                
                // Economic Principle: Supply & Demand / Scarcity
                costs[type] = Math.floor(price * costMultipliers[type]);

                createFloatingText(x, y, "資産計上!", "#10b981");
                createFloatingText(canvas.width/2, 100, `需要増により${type === 'bond' ? '債券' : type === 'stock' ? '株価' : '不動産価格'}上昇!`, "#fbbf24");

                selectTower(towers[towers.length - 1]);

                updateUI();
            }
        }

        function upgradeSelectedTower(e) {
            e?.stopPropagation();
            if (!selectedTower) return;
            selectedTower.attemptUpgrade();
        }

        function sellSelectedTower(e) {
            e?.stopPropagation();
            if (!selectedTower) return;
            const tower = selectedTower;
            const refund = Math.floor(tower.invested * sellRefundRate);
            gold += refund;
            towers = towers.filter(t => t !== tower);
            createFloatingText(tower.x, tower.y, `売却 +¥${refund}`, '#34d399');
            createFloatingText(canvas.width/2, canvas.height - 100, '再配置モードに移行', '#93c5fd');
            updateUI();
            selectTower(null);
            setBuildMode(tower.type);
        }

        function selectTower(tower) {
            selectedTower = tower;
            updateTowerPanel();
        }

        function getTowerAt(x, y) {
            return towers.find(t => Math.hypot(t.x - x, t.y - y) < 16);
        }

        function updateTowerPanel() {
            const panel = document.getElementById('towerPanel');
            const nameEl = document.getElementById('towerName');
            const statsEl = document.getElementById('towerStats');
            const upgradeCostEl = document.getElementById('towerUpgradeCost');
            const sellRefundEl = document.getElementById('towerSellRefund');
            const helperText = document.getElementById('towerCosts');

            if (!panel) return;

            if (!selectedTower) {
                panel.classList.add('hidden');
                nameEl.innerText = 'タワー未選択';
                statsEl.innerText = '射程/ダメージ/クールダウン';
                upgradeCostEl.innerText = '';
                sellRefundEl.innerText = '';
                helperText.innerText = 'タワーをクリックすると詳細が表示されます。';
                return;
            }

            panel.classList.remove('hidden');
            nameEl.innerText = `${selectedTower.label} Lv.${selectedTower.level}`;
            statsEl.innerText = `射程: ${Math.round(selectedTower.range)} / ダメージ: ${selectedTower.damage.toFixed(1)} / CD: ${selectedTower.cooldown.toFixed(2)}s`;
            upgradeCostEl.innerText = `¥${selectedTower.upgradeCost}`;
            sellRefundEl.innerText = `¥${Math.floor(selectedTower.invested * sellRefundRate)}`;
            helperText.innerText = '強化コストは市場インフレ係数と連動し、売却時は一部返戻されます。';

            document.getElementById('btnTowerUpgrade').style.opacity = gold >= selectedTower.upgradeCost ? 1 : 0.5;
        }

        function upgradeHero(e) {
            e.stopPropagation();
            if (gold >= costs.upgrade) {
                gold -= costs.upgrade;
                costs.upgrade = Math.floor(costs.upgrade * costMultipliers.upgrade);
                hero.upgrade();
                updateUI();
            } else {
                createFloatingText(canvas.width/2, canvas.height - 100, "資金不足です", "#ef4444");
            }
        }

        function getWaveComposition(wave) {
            const baseCount = 5 + Math.floor(wave * 2.5);

            const pools = [
                { maxWave: 2, data: [{ type: 'basic', weight: 1 }] },
                { maxWave: 4, data: [{ type: 'basic', weight: 0.7 }, { type: 'fast', weight: 0.3 }] },
                { maxWave: 6, data: [{ type: 'basic', weight: 0.55 }, { type: 'fast', weight: 0.25 }, { type: 'tank', weight: 0.2 }] },
                { maxWave: 9, data: [{ type: 'basic', weight: 0.45 }, { type: 'fast', weight: 0.25 }, { type: 'tank', weight: 0.2 }, { type: 'healer', weight: 0.1 }] }
            ];

            let pool = pools[pools.length - 1].data;
            for (const p of pools) {
                if (wave <= p.maxWave) { pool = p.data; break; }
            }

            if (wave >= 10 && wave % 5 === 0) {
                return { count: baseCount, interval: Math.max(0.6, 2.0 - (wave * 0.1)), pool, boss: true };
            }

            return { count: baseCount, interval: Math.max(0.6, 2.0 - (wave * 0.1)), pool };
        }

        function buildSpawnQueue(composition) {
            const queue = [];
            const pool = composition.pool;
            const totalWeight = pool.reduce((sum, p) => sum + p.weight, 0);

            const pickType = () => {
                let roll = Math.random() * totalWeight;
                for (const p of pool) {
                    roll -= p.weight;
                    if (roll <= 0) return p.type;
                }
                return pool[0].type;
            };

            for (let i = 0; i < composition.count; i++) {
                queue.push(pickType());
            }

            if (composition.boss) {
                queue.push('boss');
            }

            return queue;
        }

        function announceNewEnemies(types) {
            const messages = [];
            types.forEach(t => {
                if (!discoveredEnemyTypes.has(t)) {
                    discoveredEnemyTypes.add(t);
                    messages.push(`${enemyTypes[t].label}: ${enemyTypes[t].description}`);
                }
            });
            if (messages.length > 0) {
                const info = messages.join(' / ');
                createFloatingText(canvas.width/2, canvas.height/2 - 30, `新敵出現! ${info}`, '#fbbf24');
                document.getElementById('enemyInfo').innerText = info;
                document.getElementById('enemyInfo').title = info;
            }
        }

        function startWave() {
            waveTimer = 0;
            const composition = getWaveComposition(wave);
            spawnQueue = buildSpawnQueue(composition);
            enemiesToSpawn = spawnQueue.length;
            spawnInterval = composition.interval;
            spawnTimer = 0;
            elWave.innerText = wave;

            // Increase interest rate slightly per wave (Central bank adjustment)
            interestRate = Math.min(0.20, 0.05 + (wave * 0.005));

            createFloatingText(canvas.width/2, canvas.height/2, `インフレ波 ${wave} 到来!`, "#ef4444");
            const uniqueTypes = new Set(spawnQueue);
            uniqueTypes.delete('basic');
            announceNewEnemies(uniqueTypes);
            if (composition.boss) {
                createFloatingText(canvas.width/2, canvas.height/2 + 30, `${enemyTypes.boss.label}が市場を揺らす!`, '#fde047');
            }
        }

        function spawnEnemy() {
            const type = spawnQueue.shift() || 'basic';
            enemies.push(new Enemy(wave, type));
            enemiesToSpawn = spawnQueue.length;
        }

        function takeBaseDamage(amount) {
            baseHealth -= amount;
            // Screen shake effect logic could go here
            if (baseHealth <= 0) {
                endGame();
            }
        }

        function endGame() {
            gameState = 'GAMEOVER';
            elModal.classList.remove('hidden');
            elTitle.innerText = "経済崩壊 (Game Over)";
            elTitle.className = "text-4xl md:text-6xl font-bold text-red-500 mb-4 retro-text";
            elDesc.innerHTML = `あなたのGDP: <span class="text-yellow-400 font-bold">¥${score}</span><br>到達ウェーブ: ${wave}<br><br>インフレに耐えきれませんでした。<br>次こそは適切な市場介入を。`;
            elBtnStart.innerText = "経済再建 (Retry)";
        }

        function getNearestEnemy(x, y, range) {
            let nearest = null;
            let minDst = range;
            for (let e of enemies) {
                if (e.dead) continue;
                const dx = e.x - x;
                const dy = e.y - y;
                const dst = Math.sqrt(dx*dx + dy*dy);
                if (dst < minDst) {
                    minDst = dst;
                    nearest = e;
                }
            }
            return nearest;
        }

        function updateEconomy(dt) {
            // Compound Interest Logic
            interestTimer += dt * 1000;
            if (interestTimer >= interestInterval) {
                const interest = Math.floor(gold * interestRate);
                if (interest > 0) {
                    gold += interest;
                    createFloatingText(canvas.width - 100, 80, `+利子 ¥${interest}`, "#10b981");
                    updateUI();
                }
                interestTimer = 0;
            }
        }

        function createFloatingText(x, y, text, color) {
            const el = document.createElement('div');
            el.className = 'floating-text';
            el.innerText = text;
            el.style.color = color;
            el.style.left = x + 'px';
            el.style.top = y + 'px';
            gameContainer.appendChild(el);
            setTimeout(() => el.remove(), 1000);
        }

        function createParticle(x, y, type, color) {
            for(let i=0; i<5; i++) {
                particles.push(new Particle(x, y, type, color));
            }
        }

        function updateUI() {
            elGold.innerText = `¥${gold.toLocaleString()}`;
            elScore.innerText = `¥${score.toLocaleString()}`;
            elInterest.innerText = `${(interestRate * 100).toFixed(1)}% / 5秒`;
            
            // Update buttons
            document.getElementById('costBond').innerText = `¥${costs.bond}`;
            document.getElementById('costStock').innerText = `¥${costs.stock}`;
            document.getElementById('costRealEstate').innerText = `¥${costs.realEstate}`;
            document.getElementById('costUpgrade').innerText = `¥${costs.upgrade}`;

            // Greying out buttons
            btnBuyBond.style.opacity = gold >= costs.bond ? 1 : 0.5;
            btnBuyStock.style.opacity = gold >= costs.stock ? 1 : 0.5;
            btnBuyRealEstate.style.opacity = gold >= costs.realEstate ? 1 : 0.5;
            btnHeroUpgrade.style.opacity = gold >= costs.upgrade ? 1 : 0.5;

            updateTowerPanel();
        }

        function gameLoop(timestamp) {
            const dt = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            if (gameState === 'PLAYING') {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw Base (Central Bank/Treasury)
                ctx.fillStyle = '#f59e0b';
                ctx.beginPath();
                ctx.arc(canvas.width/2, canvas.height/2, 30, 0, Math.PI*2);
                ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`国庫: ${Math.floor(baseHealth)}%`, canvas.width/2, canvas.height/2 + 5);

                // Spawning Logic
                if (enemiesToSpawn > 0) {
                    spawnTimer += dt;
                    if (spawnTimer > spawnInterval) {
                        spawnEnemy();
                        spawnTimer = 0;
                    }
                } else if (enemies.length === 0) {
                    // Wave clear
                    wave++;
                    startWave();
                }

                // Update & Draw Entities
                hero.update(dt);
                hero.draw(ctx);

                towers.forEach(t => {
                    t.update(dt);
                    t.draw(ctx);
                });

                projectiles = projectiles.filter(p => !p.dead);
                projectiles.forEach(p => {
                    p.update(dt);
                    p.draw(ctx);
                });

                enemies = enemies.filter(e => !e.dead);
                enemies.forEach(e => {
                    e.update(dt);
                    e.draw(ctx);
                });

                particles = particles.filter(p => p.life > 0);
                particles.forEach(p => {
                    p.update(dt);
                    p.draw(ctx);
                });

                // Economy
                updateEconomy(dt);

                // Build Mode Preview
                if (buildingMode) {
                    ctx.beginPath();
                    ctx.arc(mouseX, mouseY, 15, 0, Math.PI * 2);
                    ctx.strokeStyle = '#fff';
                    ctx.setLineDash([5, 5]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }

            requestAnimationFrame(gameLoop);
        }

        // Init
        init();

    </script>
</body>
</html>
